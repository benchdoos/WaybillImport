package com.maykop_mmz.ppo.waybillImport.gui;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;
import com.linuxense.javadbf.DBFException;
import com.linuxense.javadbf.DBFReader;
import com.linuxense.javadbf.DBFUtils;
import com.maykop_mmz.ppo.waybillImport.core.ApplicationConstants;
import com.maykop_mmz.ppo.waybillImport.core.Main;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.DBase3Dao;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.Stores;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.atom.ManipulatorIndex;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.atom.OstDBValues;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.structures.ConsumptionWaybillStructure;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.structures.IncomingWaybillStructure;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.types.ConsumptionWaybillRecord;
import com.maykop_mmz.ppo.waybillImport.dbase3Dao.types.IncomingWaybillRecord;
import com.maykop_mmz.ppo.waybillImport.utils.FrameUtils;
import com.maykop_mmz.ppo.waybillImport.utils.Logging;
import com.maykop_mmz.ppo.waybillImport.utils.PropertiesNames;
import com.maykop_mmz.ppo.waybillImport.utils.PropertiesUtils;
import org.apache.log4j.Logger;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import static com.maykop_mmz.ppo.waybillImport.dbase3Dao.DBase3Dao.manipulatorIndexHashMap;

public class MainFrame extends JFrame {
    private final Color DEFAULT_GREEN_COLOR = new Color(0, 172, 0);
    private Logger log = Logger.getLogger(Logging.getCurrentClassName());
    private JPanel contentPane;
    private JButton buttonOK;
    private JButton buttonCancel;
    private JTextField ostDbfTextField;
    private JTextField prih1DbfTextField;
    private JTextField rash1DbfTextField;
    private JTextField prih3DbfTextField;
    private JTextField rash3DbfTextField;
    private JButton ostSearchButton;
    private JButton prih1SearchButton;
    private JButton rash1SearchButton;
    private JButton prih3SearchButton;
    private JButton rash3SearchButton;
    private JLabel statusLabel;
    private JTextPane textPane;
    private JLabel ostLabel;
    private JLabel prih1Label;
    private JLabel prih3Label;
    private JLabel rash1Label;
    private JLabel rash3Label;
    private JScrollPane scrollPane;
    private JTabbedPane tabbedPane;
    private JPanel mainTab;
    private JPanel processTab;
    private boolean filesChecked = false;

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    public MainFrame() {
        createGui();
        fillSettingsToFields();
        pushInfoToTextPane("Логирование в " + System.getProperty(ApplicationConstants.APP_LOG_PROPERTY), Level.INFO);
    }

    private static void copyFile(String sourcePath, String targetPath) throws IOException {
        Path source = Paths.get(sourcePath);
        Path target = Paths.get(targetPath);
        Files.copy(source, target);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return contentPane;
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        contentPane = new JPanel();
        contentPane.setLayout(new GridLayoutManager(2, 1, new Insets(10, 10, 10, 10), -1, -1));
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 3, new Insets(0, 0, 0, 0), -1, -1));
        contentPane.add(panel1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, 1, null, null, null, 0, false));
        final Spacer spacer1 = new Spacer();
        panel1.add(spacer1, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1, true, false));
        panel1.add(panel2, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        buttonOK = new JButton();
        buttonOK.setText("ОК");
        panel2.add(buttonOK, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        buttonCancel = new JButton();
        buttonCancel.setText("Отмена");
        panel2.add(buttonCancel, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel3 = new JPanel();
        panel3.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        panel1.add(panel3, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, -1), new Dimension(200, -1), 0, false));
        statusLabel = new JLabel();
        statusLabel.setText("");
        statusLabel.setVisible(true);
        panel3.add(statusLabel, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_VERTICAL, 1, GridConstraints.SIZEPOLICY_FIXED, new Dimension(0, -1), new Dimension(200, -1), new Dimension(200, 20), 0, false));
        tabbedPane = new JTabbedPane();
        contentPane.add(tabbedPane, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(200, 200), null, 0, false));
        mainTab = new JPanel();
        mainTab.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Главная", mainTab);
        final JPanel panel4 = new JPanel();
        panel4.setLayout(new GridLayoutManager(5, 3, new Insets(0, 0, 0, 0), -1, -1));
        panel4.setName("Hello");
        mainTab.add(panel4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        ostLabel = new JLabel();
        ostLabel.setText("База остатков (ost.dbf)");
        panel4.add(ostLabel, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        ostDbfTextField = new JTextField();
        panel4.add(ostDbfTextField, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
        ostSearchButton = new JButton();
        ostSearchButton.setText("Обзор");
        panel4.add(ostSearchButton, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        prih1Label = new JLabel();
        prih1Label.setText("База прихода СЗ (prih1.dbf)");
        panel4.add(prih1Label, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        prih1DbfTextField = new JTextField();
        panel4.add(prih1DbfTextField, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
        prih1SearchButton = new JButton();
        prih1SearchButton.setText("Обзор");
        panel4.add(prih1SearchButton, new GridConstraints(1, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        rash1Label = new JLabel();
        rash1Label.setText("База расхода СЗ (rash1.dbf)");
        panel4.add(rash1Label, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        rash1DbfTextField = new JTextField();
        panel4.add(rash1DbfTextField, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
        rash1SearchButton = new JButton();
        rash1SearchButton.setText("Обзор");
        panel4.add(rash1SearchButton, new GridConstraints(2, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        prih3Label = new JLabel();
        prih3Label.setText("База прихода СГ (prih3.dbf)");
        panel4.add(prih3Label, new GridConstraints(3, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        prih3DbfTextField = new JTextField();
        panel4.add(prih3DbfTextField, new GridConstraints(3, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
        prih3SearchButton = new JButton();
        prih3SearchButton.setText("Обзор");
        panel4.add(prih3SearchButton, new GridConstraints(3, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        rash3Label = new JLabel();
        rash3Label.setText("База расхода СГ (rash3.dbf)");
        panel4.add(rash3Label, new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        rash3DbfTextField = new JTextField();
        panel4.add(rash3DbfTextField, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
        rash3SearchButton = new JButton();
        rash3SearchButton.setText("Обзор");
        panel4.add(rash3SearchButton, new GridConstraints(4, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final Spacer spacer2 = new Spacer();
        mainTab.add(spacer2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, 1, GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        processTab = new JPanel();
        processTab.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Процесс", processTab);
        scrollPane = new JScrollPane();
        scrollPane.putClientProperty("html.disable", Boolean.FALSE);
        processTab.add(scrollPane, new GridConstraints(0, 0, 2, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        textPane = new JTextPane();
        textPane.setContentType("text/html");
        scrollPane.setViewportView(textPane);
        ostLabel.setLabelFor(ostDbfTextField);
        prih1Label.setLabelFor(prih1DbfTextField);
        rash1Label.setLabelFor(rash1DbfTextField);
        prih3Label.setLabelFor(prih3DbfTextField);
        rash3Label.setLabelFor(rash3DbfTextField);
    }

    private void changeLabelColorsToDefault() {
        ostLabel.setForeground(Color.black);
        prih1Label.setForeground(Color.black);
        rash1Label.setForeground(Color.black);
        prih3Label.setForeground(Color.black);
        rash3Label.setForeground(Color.black);
    }

    private void checkFile(JLabel label, String path) throws FileNotFoundException {
        if (checkFileExistence(path)) {
            label.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок", Level.SUCCESS);
        } else {
            label.setForeground(Color.red);
            throw new FileNotFoundException("Can not find ost file: " + path);
        }
    }

    private boolean checkFileExistence(String path) {
        return new File(path).exists();
    }

    private void checkFilesLocations() throws FileNotFoundException {
        pushInfoToTextPane("Проверяю путь к файлу остатков", Level.INFO);
        checkFile(ostLabel, ostDbfTextField.getText());

        pushInfoToTextPane("Проверяю путь к файлу прихода СЗ", Level.INFO);
        checkFile(prih1Label, prih1DbfTextField.getText());

        pushInfoToTextPane("Проверяю путь к файлу расхода СЗ", Level.INFO);
        checkFile(rash1Label, rash1DbfTextField.getText());

        pushInfoToTextPane("Проверяю путь к файлу прихода СГ", Level.INFO);
        checkFile(prih3Label, prih3DbfTextField.getText());

        pushInfoToTextPane("Проверяю путь к файлу расхода СГ", Level.INFO);
        checkFile(rash3Label, rash3DbfTextField.getText());

        changeLabelColorsToDefault();

    }

    private void checkFilesStructure() { //FixMe если поменять rash и prih местами, prih спокойно сожрет rash.
        try {
            pushInfoToTextPane("Проверяем структуру файла остатков", Level.INFO);
            checkOstStructure(ostDbfTextField.getText());
            ostLabel.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);

            pushInfoToTextPane("Проверяем структуру файла прихода СЗ", Level.INFO);
            checkPrih1Structure(prih1DbfTextField.getText());
            prih1Label.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);

            pushInfoToTextPane("Проверяем структуру файла расхода СЗ", Level.INFO);
            checkRash1Structure(rash1DbfTextField.getText());
            rash1Label.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);

            pushInfoToTextPane("Проверяем структуру файла прихода СГ", Level.INFO);
            checkPrih3Structure(prih3DbfTextField.getText());
            prih3Label.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);

            pushInfoToTextPane("Проверяем структуру файла расхода СГ", Level.INFO);
            checkRash3Structure(rash3DbfTextField.getText());
            rash3Label.setForeground(DEFAULT_GREEN_COLOR);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);

            changeLabelColorsToDefault();
        } catch (DBFException e) {
            log.warn("Something wrong in dbf's structure", e);
            pushInfoToTextPane("Не удалось прочитать файл: " + e.getMessage(), Level.WARN);
            throw e;
        }
    }

    private void checkOstStructure(String path) throws DBFException {
        log.info("Scanning structure of ost in: " + path);
        DBFReader reader = null;
        try {
            reader = new DBFReader(new FileInputStream(path), Charset.forName(DBase3Dao.DEFAULT_DBF_CHARSET));
            DBase3Dao.generateOstStructure(reader, new File(path));
        } catch (DBFException | IOException e) {
            log.warn("Can not read " + path, e);
            throw new DBFException(e);
        } finally {
            DBFUtils.close(reader);
        }
    }

    private void checkPrih1Structure(String path) {
        log.info("Scanning structure of prih1 in: " + path);
        DBFReader reader = null;
        try {
            reader = new DBFReader(new FileInputStream(path), Charset.forName(DBase3Dao.DEFAULT_DBF_CHARSET));
            IncomingWaybillStructure structure = DBase3Dao.generateIncomingWaybillStructure(reader, new File(path));
            DBase3Dao.setPrih1Structure(structure);
        } catch (DBFException | IOException e) {
            log.warn("Can not read " + path, e);
            throw new DBFException(e);
        } finally {
            DBFUtils.close(reader);
        }
    }

    private void checkPrih3Structure(String path) {
        log.info("Scanning structure of prih3 in: " + path);
        DBFReader reader = null;
        try {
            reader = new DBFReader(new FileInputStream(path), Charset.forName(DBase3Dao.DEFAULT_DBF_CHARSET));
            IncomingWaybillStructure structure = DBase3Dao.generateIncomingWaybillStructure(reader, new File(path));
            DBase3Dao.setPrih3Structure(structure);
        } catch (DBFException | IOException e) {
            log.warn("Can not read " + path, e);
            throw new DBFException(e);
        } finally {
            DBFUtils.close(reader);
        }
    }

    private void checkRash1Structure(String path) {
        log.info("Scanning structure of rash1 in: " + path);
        DBFReader reader = null;
        try {
            reader = new DBFReader(new FileInputStream(path), Charset.forName(DBase3Dao.DEFAULT_DBF_CHARSET));
            final ConsumptionWaybillStructure structure = DBase3Dao.generateConsumptionWaybillStructure(reader, new File(path));
            DBase3Dao.setRash1Structure(structure);

        } catch (DBFException | IOException e) {
            log.warn("Can not read " + path, e);
            throw new DBFException(e);
        } finally {
            DBFUtils.close(reader);
        }
    }

    private void checkRash3Structure(String path) {
        log.info("Scanning structure of rash3 in: " + path);
        DBFReader reader = null;
        try {
            reader = new DBFReader(new FileInputStream(path), Charset.forName(DBase3Dao.DEFAULT_DBF_CHARSET));
            final ConsumptionWaybillStructure structure = DBase3Dao.generateConsumptionWaybillStructure(reader, new File(path));
            DBase3Dao.setRash3Structure(structure);

        } catch (DBFException | IOException e) {
            log.warn("Can not read " + path, e);
            throw new DBFException(e);
        } finally {
            DBFUtils.close(reader);
        }
    }

    private void createGui() {
        setContentPane(contentPane);
        setTitle("Импорт накладных в БД DBase3 - ООО \"ММЗ\"");
        setIconImage(Toolkit.getDefaultToolkit().getImage(MainFrame.class.getResource("/img/logo.png")));
        getRootPane().setDefaultButton(buttonOK);

        textPane.setContentType("text/html");
        textPane.setText("<html>");

        buttonOK.addActionListener(e -> onOK());

        buttonCancel.addActionListener(e -> onCancel());

        ostSearchButton.addActionListener(e -> {
            String path = openFileBrowser();
            if (path != null)
                ostDbfTextField.setText(path);
        });

        prih1SearchButton.addActionListener(e -> {
            String path = openFileBrowser();
            if (path != null) {
                prih1DbfTextField.setText(path);
            }
        });

        rash1SearchButton.addActionListener(e -> {
            String path = openFileBrowser();
            if (path != null) {
                rash1DbfTextField.setText(path);
            }
        });
        prih3SearchButton.addActionListener(e -> {
            String path = openFileBrowser();
            if (path != null) {
                prih3DbfTextField.setText(path);
            }
        });
        rash3SearchButton.addActionListener(e -> {
            String path = openFileBrowser();
            if (path != null) {
                rash3DbfTextField.setText(path);
            }
        });

        textPane.setEditorKit(JEditorPane.createEditorKitForContentType("text/html"));
        textPane.setEditable(false);
        textPane.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void changedUpdate(DocumentEvent e) {
                textPane.setCaretPosition(textPane.getDocument().getLength());
            }

            @Override
            public void insertUpdate(DocumentEvent e) {
                textPane.setCaretPosition(textPane.getDocument().getLength());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                textPane.setCaretPosition(textPane.getDocument().getLength());
            }
        });

        statusLabel.setMinimumSize(new Dimension(200, -1));
        statusLabel.setPreferredSize(new Dimension(200, -1));
        statusLabel.setMaximumSize(new Dimension(200, -1));

        // call onCancel() when cross is clicked
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                onCancel();
            }
        });

        // call onCancel() on ESCAPE
        contentPane.registerKeyboardAction(e -> onCancel(), KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        pack();
        setMinimumSize(getSize());
        setLocation(FrameUtils.getFrameOnCenterLocationPoint(this));
    }

    private void fillSettingsToFields() {
        log.info("Loading settings to panel");
        ostDbfTextField.setText(PropertiesUtils.getProperty(PropertiesNames.OST_DBF_NAME));
        ostDbfTextField.setCaretPosition(ostDbfTextField.getText().length());

        prih1DbfTextField.setText(PropertiesUtils.getProperty(PropertiesNames.PRIH1_DBF_NAME));
        prih1DbfTextField.setCaretPosition(prih1DbfTextField.getText().length());

        rash1DbfTextField.setText(PropertiesUtils.getProperty(PropertiesNames.RASH1_DBF_NAME));
        rash1DbfTextField.setCaretPosition(rash1DbfTextField.getText().length());

        prih3DbfTextField.setText(PropertiesUtils.getProperty(PropertiesNames.PRIH3_DBF_NAME));
        prih3DbfTextField.setCaretPosition(prih3DbfTextField.getText().length());

        rash3DbfTextField.setText(PropertiesUtils.getProperty(PropertiesNames.RASH3_DBF_NAME));
        rash3DbfTextField.setCaretPosition(rash3DbfTextField.getText().length());
    }

    private void importPrih1(IncomingWaybillStructure prih1Structure, Date date) throws IOException {
        log.info("Starting import prih1 since date: " + date);
        pushInfoToTextPane("Начинаем составлять списки изменений для прихода СЗ начиная с " + date, Level.INFO);
        ArrayList<IncomingWaybillRecord> prih1List = DBase3Dao.getIncomingWaybillsAfterDateArrayList(prih1Structure, date);
        log.debug("prih1 suitable waybills count: " + prih1List.size());
        pushInfoToTextPane("Необходимо произвести изменения по " + prih1List.size() + " записям", Level.INFO);
        for (IncomingWaybillRecord record : prih1List) {
            ManipulatorIndex manipulatorIndex = record.getManipulatorIndex();

            OstDBValues values = new OstDBValues(record.getCount(), new BigDecimal(0),
                    new BigDecimal(0), new BigDecimal(0));

            if (manipulatorIndexHashMap.containsKey(manipulatorIndex)) {
                OstDBValues summed = manipulatorIndexHashMap.get(manipulatorIndex).add(values);
                manipulatorIndexHashMap.put(manipulatorIndex, summed);
            } else {
                manipulatorIndexHashMap.put(manipulatorIndex, values);
            }
        }
        //DBase3Dao.printMap(manipulatorIndexHashMap);
        log.info("Checked records: " + prih1List.size());
        pushInfoToTextPane("Все ок.", Level.SUCCESS);
    }

    private void importPrih3(IncomingWaybillStructure prih3Structure, Date date) throws IOException {
        log.info("Starting import prih3 since date: " + date);
        pushInfoToTextPane("Начинаем составлять списки изменений для прихода СГ начиная с " + date, Level.INFO);
        ArrayList<IncomingWaybillRecord> prih1List = DBase3Dao.getIncomingWaybillsAfterDateArrayList(prih3Structure, date);
        log.debug("prih3 suitable waybills count: " + prih1List.size());
        pushInfoToTextPane("Необходимо произвести изменения по " + prih1List.size() + " записям", Level.INFO);
        for (IncomingWaybillRecord record : prih1List) {
            ManipulatorIndex manipulatorIndex = record.getManipulatorIndex();

            OstDBValues values = new OstDBValues(new BigDecimal(0), new BigDecimal(-record.getCount().intValue()),
                    record.getCount(), new BigDecimal(0));

            if (manipulatorIndexHashMap.containsKey(manipulatorIndex)) {
                OstDBValues summed = manipulatorIndexHashMap.get(manipulatorIndex).add(values);
                manipulatorIndexHashMap.put(manipulatorIndex, summed);
            } else {
                manipulatorIndexHashMap.put(manipulatorIndex, values);
            }
        }
        //DBase3Dao.printMap(manipulatorIndexHashMap);
        log.info("Checked records: " + prih1List.size());
        pushInfoToTextPane("Все ок.", Level.SUCCESS);
    }

    private void importRash1(ConsumptionWaybillStructure rash1Structure, Date date) throws IOException {
        log.info("Starting import rash1 since date: " + date);
        pushInfoToTextPane("Начинаем составлять списки изменений для расхода СЗ начиная с " + date, Level.INFO);
        ArrayList<ConsumptionWaybillRecord> rash1List = DBase3Dao.getConsumptionWaybillAfterDateArrayList(rash1Structure, date);
        log.debug("prih1 suitable waybills count: " + rash1List.size());
        pushInfoToTextPane("Необходимо произвести изменения по " + rash1List.size() + " записям", Level.INFO);
        for (ConsumptionWaybillRecord record : rash1List) {
            ManipulatorIndex manipulatorIndex = record.getManipulatorIndex();
            OstDBValues values = null;
            if (record.getStore() == Stores.MZ1) {
                values = new OstDBValues(new BigDecimal(-record.getCount().intValue()), record.getCount(),
                        new BigDecimal(0), new BigDecimal(0));
            } else if (record.getStore() == Stores.PZ1) {
                values = new OstDBValues(new BigDecimal(-record.getCount().intValue()), new BigDecimal(0),
                        new BigDecimal(0), record.getCount());
            } else {
                log.warn("Can not parse record: " + record);
            }

            if (values != null) {
                if (manipulatorIndexHashMap.containsKey(manipulatorIndex)) {
                    OstDBValues summed = manipulatorIndexHashMap.get(manipulatorIndex).add(values);
                    manipulatorIndexHashMap.put(manipulatorIndex, summed);
                } else {
                    manipulatorIndexHashMap.put(manipulatorIndex, values);
                }
            }
        }
        //DBase3Dao.printMap(manipulatorIndexHashMap);
        log.info("Checked records: " + rash1List.size());
        pushInfoToTextPane("Все ок.", Level.SUCCESS);
    }

    private void importRash3(ConsumptionWaybillStructure rash3Structure, Date date) throws IOException {
        log.info("Starting import rash3 since date: " + date);
        pushInfoToTextPane("Начинаем составлять списки изменений для расхода СГ начиная с " + date, Level.INFO);
        ArrayList<ConsumptionWaybillRecord> rash1List = DBase3Dao.getConsumptionWaybillAfterDateArrayList(rash3Structure, date);
        log.debug("prih1 suitable waybills count: " + rash1List.size());
        pushInfoToTextPane("Необходимо произвести изменения по " + rash1List.size() + " записям", Level.INFO);
        for (ConsumptionWaybillRecord record : rash1List) {
            ManipulatorIndex manipulatorIndex = record.getManipulatorIndex();
            OstDBValues values = null;
            if (record.getStore() == Stores.MZ1) {
                values = new OstDBValues(new BigDecimal(0), record.getCount(),
                        new BigDecimal(-record.getCount().intValue()), new BigDecimal(0));
            } else if (record.getStore() == Stores.PZ1) {
                values = new OstDBValues(new BigDecimal(0), new BigDecimal(0),
                        new BigDecimal(-record.getCount().intValue()), record.getCount());
            } else {
                log.warn("Can not parse record: " + record);
            }

            if (values != null) {
                if (manipulatorIndexHashMap.containsKey(manipulatorIndex)) {
                    OstDBValues summed = manipulatorIndexHashMap.get(manipulatorIndex).add(values);
                    manipulatorIndexHashMap.put(manipulatorIndex, summed);
                } else {
                    manipulatorIndexHashMap.put(manipulatorIndex, values);
                }
            }
        }
        //DBase3Dao.printMap(manipulatorIndexHashMap);
        log.info("Checked records: " + rash1List.size());
        pushInfoToTextPane("Все ок.", Level.SUCCESS);
    }

    private void makeBackup() {
        final Date date = Calendar.getInstance().getTime();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
        String fixedDate = df.format(date);
        final String path = ApplicationConstants.APP_BACKUP_FOLDER + File.separator + fixedDate + File.separator;


        String oldFile = ostDbfTextField.getText();
        try {
            pushInfoToTextPane("Создаем копию " + oldFile, Level.INFO);
            makeDBCopies(oldFile, path);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);
        } catch (IOException e) {
            final String newFile = ApplicationConstants.APP_BACKUP_FOLDER + new File(oldFile).getName();

            log.warn("Could not copy file " + oldFile + " to " + newFile);
            pushInfoToTextPane("Не удалось скопировать " + oldFile + " в "
                    + newFile, Level.WARN);
        }

        oldFile = prih1DbfTextField.getText();
        try {
            pushInfoToTextPane("Создаем копию " + oldFile, Level.INFO);
            makeDBCopies(oldFile, path);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);
        } catch (IOException e) {
            final String newFile = ApplicationConstants.APP_BACKUP_FOLDER + new File(oldFile).getName();
            pushInfoToTextPane("Не удалось скопировать " + oldFile + " в "
                    + newFile, Level.WARN);
        }

        oldFile = rash1DbfTextField.getText();
        try {
            pushInfoToTextPane("Создаем копию " + oldFile, Level.INFO);
            makeDBCopies(oldFile, path);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);
        } catch (IOException e) {
            final String newFile = ApplicationConstants.APP_BACKUP_FOLDER + new File(oldFile).getName();
            pushInfoToTextPane("Не удалось скопировать " + oldFile + " в "
                    + newFile, Level.WARN);
        }

        oldFile = prih3DbfTextField.getText();
        try {
            pushInfoToTextPane("Создаем копию " + oldFile, Level.INFO);
            makeDBCopies(oldFile, path);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);
        } catch (IOException e) {
            final String newFile = ApplicationConstants.APP_BACKUP_FOLDER + new File(oldFile).getName();
            pushInfoToTextPane("Не удалось скопировать " + oldFile + " в "
                    + newFile, Level.WARN);
        }
        oldFile = rash3DbfTextField.getText();
        try {
            pushInfoToTextPane("Создаем копию " + oldFile, Level.INFO);
            makeDBCopies(oldFile, path);
            pushInfoToTextPane("Все ок.", Level.SUCCESS);
        } catch (IOException e) {
            final String newFile = ApplicationConstants.APP_BACKUP_FOLDER + new File(oldFile).getName();
            pushInfoToTextPane("Не удалось скопировать " + oldFile + " в "
                    + newFile, Level.WARN);
        }
    }

    private void makeDBCopies(String sourcePath, String targetFolder) throws IOException {
        File folder = new File(targetFolder);
        pushInfoToTextPane("Делаем копии в " + folder.getPath(), Level.INFO);

        String targetPath = folder.getAbsolutePath() + File.separator + new File(sourcePath).getName();

        File targetFile = new File(targetPath);

        if (!folder.exists()) {
            if (folder.mkdirs()) {
                copyFile(sourcePath, targetFile.getPath());
            }

        } else {
            copyFile(sourcePath, targetFile.getPath());
        }
    }

    private void onCancel() {
        dispose();
    }

    private void onOK() {
        if (!filesChecked) {
            saveSettings();
            try {
                checkFilesLocations();
                checkFilesStructure();
                filesChecked = true;
            } catch (FileNotFoundException e) {
                final String fileNotFound = "Файл не найден";
                statusLabel.setText(fileNotFound);
                pushInfoToTextPane(fileNotFound, Level.WARN);
                log.warn("Could not find a file", e);
            } catch (DBFException e) {
                log.warn("Can not read file", e);
                pushInfoToTextPane("Не удалось загрузить файл" + e.getMessage(), Level.WARN);
                filesChecked = false;
            }
        } else {
            AcceptingDialog acceptingDialog = new AcceptingDialog();
            acceptingDialog.setVisible(true);
            final boolean result = acceptingDialog.result();
            log.info("Accepted: " + result);
            if (result) {
                makeBackup();
                pushInfoToTextPane("===========================================", Level.SUCCESS);
                startDataTransfer(acceptingDialog);
            }
        }
    }

    private String openFileBrowser() {
        log.debug("Opening File Browser");

        FileDialog fd = new FileDialog(this, "Выбери файл", FileDialog.LOAD);
        fd.setIconImage(Toolkit.getDefaultToolkit()
                .getImage(Main.class.getResource("/img/logo.png")));
        fd.setDirectory(System.getProperty("user.dir"));
        fd.setFile("*.dbf");
        fd.setMultipleMode(false);
        fd.setVisible(true);
        String filename = fd.getFile();
        File[] f = fd.getFiles();
        if (f.length > 0) {
            log.debug("Choice: " + fd.getFiles()[0].getAbsolutePath());
            return fd.getFiles()[0].getAbsolutePath();
        } else {
            log.debug("Choice canceled");
            return null;
        }
    }

    private void pushInfoToTextPane(String text, Level level) {
        Style style;
        StyleContext sc = new StyleContext();

        MutableAttributeSet black = new SimpleAttributeSet();
        MutableAttributeSet red = new SimpleAttributeSet();
        MutableAttributeSet green = new SimpleAttributeSet();

        StyleConstants.setForeground(black, Color.black);
        StyleConstants.setForeground(red, Color.red);
        StyleConstants.setForeground(green, DEFAULT_GREEN_COLOR);

        AttributeSet attribute;

        switch (level) {
            case INFO:
                attribute = black;
                statusLabel.setText(text);
                break;
            case WARN:
                attribute = red;
//                style.addAttribute(StyleConstants.Foreground, Color.red);
                statusLabel.setText("<html><font color='red'>" + text + "</font></html>");
                break;
            case SUCCESS:
                attribute = green;
//                style.addAttribute(StyleConstants.Foreground, DEFAULT_GREEN_COLOR);
                statusLabel.setText("<html><font color='green'>" + text + "</font></html>");
                break;
            default:
                attribute = black;
                break;
        }

        try {
            Document doc = textPane.getStyledDocument();
            doc.insertString(doc.getLength(), text + "\n", attribute);
//            doc.insertString(doc.getLength(), text + "\n", style);
        } catch (BadLocationException e) {
            log.warn("Could not add line to document", e);
        }
    }

    private void saveSettings() {
        log.info("Saving settings");
        PropertiesUtils.setProperty(PropertiesNames.OST_DBF_NAME, ostDbfTextField.getText());
        PropertiesUtils.setProperty(PropertiesNames.PRIH1_DBF_NAME, prih1DbfTextField.getText());
        PropertiesUtils.setProperty(PropertiesNames.RASH1_DBF_NAME, rash1DbfTextField.getText());
        PropertiesUtils.setProperty(PropertiesNames.PRIH3_DBF_NAME, prih3DbfTextField.getText());
        PropertiesUtils.setProperty(PropertiesNames.RASH3_DBF_NAME, rash3DbfTextField.getText());
        PropertiesUtils.saveProperties();
    }

    private void setEnabledUIElements(boolean b) {
        if (b) {
            tabbedPane.setEnabledAt(tabbedPane.indexOfTab("Главная"), true);
        } else {
            tabbedPane.setSelectedComponent(processTab);
            tabbedPane.setEnabledAt(tabbedPane.indexOfTab("Главная"), false);
        }
        buttonOK.setEnabled(b);
        buttonCancel.setEnabled(b);
    }

    private void startDataTransfer(AcceptingDialog acceptingDialog) {
        if (acceptingDialog.isDateSelected()) {
            final Date selectedDate = acceptingDialog.getSelectedDate();
            log.info("Selected date from: " + selectedDate);
            startImport(selectedDate);
        } else {
            pushInfoToTextPane("Дата, с которой нужно добавлять накладные - не указана", Level.WARN);
        }
    }

    private void startImport(final Date date) {
        setEnabledUIElements(false);
        Runnable runnable = new Runnable() {
            public void run() {
                try {
                    try {
                        importPrih1(DBase3Dao.getPrih1Structure(), date);
                        pushInfoToTextPane("Всего подготовлено к импорту записей: " + manipulatorIndexHashMap.size(), Level.SUCCESS);

                        importRash1(DBase3Dao.getRash1Structure(), date);
                        pushInfoToTextPane("Всего подготовлено к импорту записей: " + manipulatorIndexHashMap.size(), Level.SUCCESS);

                        importPrih3(DBase3Dao.getPrih3Structure(), date);
                        pushInfoToTextPane("Всего подготовлено к импорту записей: " + manipulatorIndexHashMap.size(), Level.SUCCESS);

                        importRash3(DBase3Dao.getRash3Structure(), date);
                        pushInfoToTextPane("Всего подготовлено к импорту записей: " + manipulatorIndexHashMap.size(), Level.SUCCESS);

                        DBase3Dao.printMap(DBase3Dao.manipulatorIndexHashMap);

                    } catch (IOException e) {
                        log.error("Can not load incoming waybills to stock of blanks (prih1)", e);
                        pushInfoToTextPane("Не удалось импортировать приход склада заготовок (prih1)", Level.WARN);
                        throw new IOException(e);
                    }
                } catch (IOException e1) {
                    log.error("Could not load some waybills, rolling back all operations");//TODO restore prev. dbfs
                    pushInfoToTextPane(
                            "Не удалось загрузить 1 или более типа накладных " +
                                    "в базу остатков. Откат всех операций.", Level.WARN);
                }
                setEnabledUIElements(true);
            }
        };
        SwingUtilities.invokeLater(runnable);


    }

    enum Level {INFO, SUCCESS, WARN}
}
